name: Ephemeral GitHub Runner Demo

# This workflow demonstrates the complete lifecycle of a GitHub Actions runner (organization or repository level)
# It starts an EC2 instance, registers it as a runner, executes a job, then cleans up
# The runner mode is automatically determined based on provided secrets
on:
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug logging'
        required: false
        default: 'false'
        type: boolean

# Required GitHub Secrets (Common):
# - AWS_ACCESS_KEY_ID: AWS access key for EC2 management
# - AWS_SECRET_ACCESS_KEY: AWS secret access key
# - AWS_REGION: AWS region (should be eu-west-1)
# - GH_PAT: GitHub Personal Access Token (scope depends on mode)
# - EC2_INSTANCE_ID: EC2 instance ID from Terraform output
# - RUNNER_NAME: GitHub runner name (should be gha_aws_runner)
#
# Organization Mode Secrets:
# - GITHUB_ORGANIZATION: GitHub organization name (requires admin:org scope for GH_PAT)
#
# Repository Mode Secrets:
# - GITHUB_USERNAME: GitHub username (requires repo scope for GH_PAT)
# - GITHUB_REPOSITORY: GitHub repository name (requires repo scope for GH_PAT)
#
# Note: If both organization and repository secrets are provided, repository mode takes precedence

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  RUNNER_NAME: ${{ secrets.RUNNER_NAME }}
  # Timeout and retry configurations
  MAX_RETRIES: 3
  RETRY_DELAY: 10
  SSH_TIMEOUT: 300
  INSTANCE_STOP_TIMEOUT: 300

jobs:
  # Job 0: Validate required secrets and configuration
  validate-secrets:
    runs-on: ubuntu-latest
    outputs:
      validation-passed: ${{ steps.validate.outputs.passed }}
    steps:
      - name: Validate required GitHub secrets
        id: validate
        run: |
          echo "=== Validating Required Secrets ==="
          
          # List of common required secrets
          COMMON_SECRETS=(
            "AWS_ACCESS_KEY_ID"
            "AWS_SECRET_ACCESS_KEY" 
            "AWS_REGION"
            "GH_PAT"
            "EC2_INSTANCE_ID"
            "RUNNER_NAME"
          )
          
          # Determine runner mode based on available secrets
          if [ -n "${{ secrets.GITHUB_ORGANIZATION }}" ] && [ -z "${{ secrets.GITHUB_USERNAME }}" ] && [ -z "${{ secrets.GITHUB_REPOSITORY }}" ]; then
            RUNNER_MODE="organization"
            echo "‚úÖ Detected organization mode"
            MODE_SECRETS=("GITHUB_ORGANIZATION")
          elif [ -n "${{ secrets.GITHUB_USERNAME }}" ] && [ -n "${{ secrets.GITHUB_REPOSITORY }}" ]; then
            RUNNER_MODE="repository"
            echo "‚úÖ Detected repository mode"
            MODE_SECRETS=("GITHUB_USERNAME" "GITHUB_REPOSITORY")
          elif [ -n "${{ secrets.GITHUB_ORGANIZATION }}" ] && [ -n "${{ secrets.GITHUB_USERNAME }}" ] && [ -n "${{ secrets.GITHUB_REPOSITORY }}" ]; then
            RUNNER_MODE="repository"
            echo "‚úÖ Both organization and repository secrets provided, using repository mode"
            MODE_SECRETS=("GITHUB_USERNAME" "GITHUB_REPOSITORY")
          else
            echo "‚ùå Cannot determine runner mode. Please provide either:"
            echo "   Organization mode: GITHUB_ORGANIZATION"
            echo "   Repository mode: GITHUB_USERNAME and GITHUB_REPOSITORY"
            VALIDATION_FAILED=true
          fi
          
          # Combine common and mode-specific secrets
          REQUIRED_SECRETS=("${COMMON_SECRETS[@]}" "${MODE_SECRETS[@]}")
          
          # Check each secret
          VALIDATION_FAILED=false
          
          for secret in "${REQUIRED_SECRETS[@]}"; do
            case "$secret" in
              "AWS_ACCESS_KEY_ID")
                if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret"
                fi
                ;;
              "AWS_SECRET_ACCESS_KEY")
                if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret"
                fi
                ;;
              "AWS_REGION")
                if [ -z "${{ secrets.AWS_REGION }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret (value: ${{ secrets.AWS_REGION }})"
                  # Validate region format
                  if [[ ! "${{ secrets.AWS_REGION }}" =~ ^[a-z]{2}-[a-z]+-[0-9]$ ]]; then
                    echo "‚ùå Invalid AWS region format: ${{ secrets.AWS_REGION }}"
                    VALIDATION_FAILED=true
                  fi
                fi
                ;;
              "GH_PAT")
                if [ -z "${{ secrets.GH_PAT }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret"
                fi
                ;;
              "EC2_INSTANCE_ID")
                if [ -z "${{ secrets.EC2_INSTANCE_ID }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret (value: ${{ secrets.EC2_INSTANCE_ID }})"
                  # Validate instance ID format
                  if [[ ! "${{ secrets.EC2_INSTANCE_ID }}" =~ ^i-[0-9a-f]{8,17}$ ]]; then
                    echo "‚ùå Invalid EC2 instance ID format: ${{ secrets.EC2_INSTANCE_ID }}"
                    VALIDATION_FAILED=true
                  fi
                fi
                ;;
              "RUNNER_NAME")
                if [ -z "${{ secrets.RUNNER_NAME }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret (value: ${{ secrets.RUNNER_NAME }})"
                fi
                ;;
              "GITHUB_ORGANIZATION")
                if [ -z "${{ secrets.GITHUB_ORGANIZATION }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret (value: ${{ secrets.GITHUB_ORGANIZATION }})"
                  # Validate organization name format (GitHub usernames/org names)
                  if [[ ! "${{ secrets.GITHUB_ORGANIZATION }}" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
                    echo "‚ùå Invalid GitHub organization name format: ${{ secrets.GITHUB_ORGANIZATION }}"
                    VALIDATION_FAILED=true
                  fi
                fi
                ;;
              "GITHUB_USERNAME")
                if [ -z "${{ secrets.GITHUB_USERNAME }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret (value: ${{ secrets.GITHUB_USERNAME }})"
                  # Validate username format
                  if [[ ! "${{ secrets.GITHUB_USERNAME }}" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$ ]]; then
                    echo "‚ùå Invalid GitHub username format: ${{ secrets.GITHUB_USERNAME }}"
                    VALIDATION_FAILED=true
                  fi
                fi
                ;;
              "GITHUB_REPOSITORY")
                if [ -z "${{ secrets.GITHUB_REPOSITORY }}" ]; then
                  echo "‚ùå Missing required secret: $secret"
                  VALIDATION_FAILED=true
                else
                  echo "‚úÖ Secret present: $secret (value: ${{ secrets.GITHUB_REPOSITORY }})"
                  # Validate repository name format
                  if [[ ! "${{ secrets.GITHUB_REPOSITORY }}" =~ ^[a-zA-Z0-9._-]+$ ]]; then
                    echo "‚ùå Invalid GitHub repository name format: ${{ secrets.GITHUB_REPOSITORY }}"
                    VALIDATION_FAILED=true
                  fi
                fi
                ;;
            esac
          done
          
          if [ "$VALIDATION_FAILED" = true ]; then
            echo ""
            echo "‚ùå Validation failed. Please ensure all required secrets are configured in your repository."
            echo "Go to: Settings > Secrets and variables > Actions"
            exit 1
          else
            echo ""
            echo "‚úÖ All required secrets are present and valid"
            echo "passed=true" >> $GITHUB_OUTPUT
          fi

  # Job 1: Start EC2 instance and register GitHub runner
  start-runner:
    needs: validate-secrets
    runs-on: ubuntu-latest
    outputs:
      runner-name: ${{ steps.register.outputs.runner-name }}
      instance-id: ${{ steps.start.outputs.instance-id }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate AWS credentials
        run: |
          echo "=== Validating AWS Credentials ==="
          if ! aws sts get-caller-identity; then
            echo "‚ùå AWS credentials validation failed"
            exit 1
          fi
          echo "‚úÖ AWS credentials are valid"

      - name: Start EC2 instance with retry logic
        id: start
        timeout-minutes: 10
        run: |
          echo "=== Starting EC2 Instance ==="
          
          retry_count=0
          max_retries=${{ env.MAX_RETRIES }}
          
          while [ $retry_count -lt $max_retries ]; do
            echo "Attempt $((retry_count + 1)) of $max_retries"
            
            # Check current instance state
            if INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null); then
              
              echo "Current instance state: $INSTANCE_STATE"
              
              case "$INSTANCE_STATE" in
                "running")
                  echo "‚úÖ Instance is already running"
                  break
                  ;;
                "stopped")
                  echo "Starting stopped instance..."
                  if aws ec2 start-instances --instance-ids ${{ secrets.EC2_INSTANCE_ID }}; then
                    echo "Start command sent successfully"
                    echo "Waiting for instance to be running..."
                    if timeout 300 aws ec2 wait instance-running --instance-ids ${{ secrets.EC2_INSTANCE_ID }}; then
                      echo "‚úÖ Instance is now running"
                      break
                    else
                      echo "‚ùå Timeout waiting for instance to start"
                    fi
                  else
                    echo "‚ùå Failed to send start command"
                  fi
                  ;;
                "pending"|"starting")
                  echo "Instance is starting, waiting..."
                  if timeout 300 aws ec2 wait instance-running --instance-ids ${{ secrets.EC2_INSTANCE_ID }}; then
                    echo "‚úÖ Instance is now running"
                    break
                  else
                    echo "‚ùå Timeout waiting for instance to start"
                  fi
                  ;;
                "terminated"|"terminating")
                  echo "‚ùå Instance is terminated and cannot be started"
                  exit 1
                  ;;
                *)
                  echo "‚ùå Instance in unexpected state: $INSTANCE_STATE"
                  ;;
              esac
            else
              echo "‚ùå Failed to get instance state"
            fi
            
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "Retrying in ${{ env.RETRY_DELAY }} seconds..."
              sleep ${{ env.RETRY_DELAY }}
            fi
          done
          
          if [ $retry_count -eq $max_retries ]; then
            echo "‚ùå Failed to start instance after $max_retries attempts"
            exit 1
          fi
          
          # Get instance public IP with retry logic
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            echo "Getting instance public IP (attempt $((retry_count + 1)))..."
            
            if PUBLIC_IP=$(aws ec2 describe-instances \
              --instance-ids ${{ secrets.EC2_INSTANCE_ID }} \
              --query 'Reservations[0].Instances[0].PublicIpAddress' \
              --output text 2>/dev/null) && [ "$PUBLIC_IP" != "None" ] && [ -n "$PUBLIC_IP" ]; then
              
              echo "‚úÖ Instance started with IP: $PUBLIC_IP"
              echo "instance-id=${{ secrets.EC2_INSTANCE_ID }}" >> $GITHUB_OUTPUT
              echo "public-ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
              break
            else
              echo "‚ùå Failed to get public IP or IP not yet assigned"
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                echo "Retrying in ${{ env.RETRY_DELAY }} seconds..."
                sleep ${{ env.RETRY_DELAY }}
              fi
            fi
          done
          
          if [ $retry_count -eq $max_retries ]; then
            echo "‚ùå Failed to get instance public IP after $max_retries attempts"
            exit 1
          fi

      - name: Wait for SSH to be ready
        timeout-minutes: 6
        run: |
          PUBLIC_IP=${{ steps.start.outputs.public-ip }}
          echo "=== Waiting for SSH to be ready on $PUBLIC_IP ==="
          
          # Install netcat if not available
          if ! command -v nc &> /dev/null; then
            echo "Installing netcat..."
            sudo apt-get update && sudo apt-get install -y netcat
          fi
          
          # Wait up to SSH_TIMEOUT seconds for SSH to be ready with progress indication
          timeout ${{ env.SSH_TIMEOUT }} bash -c '
            start_time=$(date +%s)
            while ! nc -z $0 22; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              echo "Waiting for SSH... (${elapsed}s elapsed)"
              sleep 10
            done
          ' $PUBLIC_IP
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ SSH is ready!"
          else
            echo "‚ùå Timeout waiting for SSH to be ready"
            exit 1
          fi

      - name: Register GitHub runner
        id: register
        timeout-minutes: 10
        run: |
          echo "=== Registering GitHub Runner ==="
          
          retry_count=0
          max_retries=${{ env.MAX_RETRIES }}
          
          while [ $retry_count -lt $max_retries ]; do
            echo "Attempt $((retry_count + 1)) of $max_retries"
            
            # Determine API endpoint based on runner mode
            if [ -n "${{ secrets.GITHUB_ORGANIZATION }}" ] && [ -z "${{ secrets.GITHUB_USERNAME }}" ]; then
              # Organization mode
              API_ENDPOINT="https://api.github.com/orgs/${{ secrets.GITHUB_ORGANIZATION }}/actions/runners/registration-token"
              RUNNER_MODE="organization"
              echo "Using organization mode: ${{ secrets.GITHUB_ORGANIZATION }}"
            elif [ -n "${{ secrets.GITHUB_USERNAME }}" ] && [ -n "${{ secrets.GITHUB_REPOSITORY }}" ]; then
              # Repository mode
              API_ENDPOINT="https://api.github.com/repos/${{ secrets.GITHUB_USERNAME }}/${{ secrets.GITHUB_REPOSITORY }}/actions/runners/registration-token"
              RUNNER_MODE="repository"
              echo "Using repository mode: ${{ secrets.GITHUB_USERNAME }}/${{ secrets.GITHUB_REPOSITORY }}"
            else
              echo "‚ùå Cannot determine runner mode from secrets"
              exit 1
            fi
            
            # Get registration token from GitHub API with error handling
            RESPONSE=$(curl -s -w "%{http_code}" -X POST \
              -H "Authorization: token ${{ secrets.GH_PAT }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "$API_ENDPOINT")
            
            HTTP_CODE="${RESPONSE: -3}"
            RESPONSE_BODY="${RESPONSE%???}"
            
            if [ "$HTTP_CODE" = "201" ]; then
              REGISTRATION_TOKEN=$(echo "$RESPONSE_BODY" | jq -r .token)
              
              if [ "$REGISTRATION_TOKEN" != "null" ] && [ -n "$REGISTRATION_TOKEN" ]; then
                echo "‚úÖ Registration token obtained successfully"
                break
              else
                echo "‚ùå Invalid registration token received"
              fi
            else
              echo "‚ùå Failed to get registration token. HTTP code: $HTTP_CODE"
              echo "Response: $RESPONSE_BODY"
              
              # Check if it's an authentication issue
              if [ "$HTTP_CODE" = "401" ]; then
                echo "‚ùå Authentication failed. Please check your GH_PAT token permissions."
                if [ "$RUNNER_MODE" = "organization" ]; then
                  echo "Required scopes for organization mode: repo, admin:org"
                else
                  echo "Required scopes for repository mode: repo"
                fi
                exit 1
              fi
            fi
            
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "Retrying in ${{ env.RETRY_DELAY }} seconds..."
              sleep ${{ env.RETRY_DELAY }}
            fi
          done
          
          if [ $retry_count -eq $max_retries ]; then
            echo "‚ùå Failed to get registration token after $max_retries attempts"
            exit 1
          fi
          
          PUBLIC_IP=${{ steps.start.outputs.public-ip }}
          
          # Set runner URL based on mode
          if [ "$RUNNER_MODE" = "organization" ]; then
            RUNNER_URL="https://github.com/${{ secrets.GITHUB_ORGANIZATION }}"
          else
            RUNNER_URL="https://github.com/${{ secrets.GITHUB_USERNAME }}/${{ secrets.GITHUB_REPOSITORY }}"
          fi
          
          # Create enhanced runner registration script with error handling
          cat > register_runner.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "=== GitHub Actions Runner Registration ==="
          echo "Runner URL: $1"
          echo "Runner Name: $3"
          
          # Download and extract GitHub Actions runner
          cd /home/ubuntu
          if [ ! -d "actions-runner" ]; then
            echo "Downloading GitHub Actions runner..."
            mkdir actions-runner && cd actions-runner
            
            # Download with retry logic
            for i in {1..3}; do
              if curl -o actions-runner-linux-x64-2.311.0.tar.gz -L \
                https://github.com/actions/runner/releases/download/v2.311.0/actions-runner-linux-x64-2.311.0.tar.gz; then
                echo "‚úÖ Runner downloaded successfully"
                break
              else
                echo "‚ùå Download attempt $i failed"
                if [ $i -eq 3 ]; then exit 1; fi
                sleep 5
              fi
            done
            
            tar xzf ./actions-runner-linux-x64-2.311.0.tar.gz
            sudo ./bin/installdependencies.sh
          else
            echo "Using existing runner installation"
            cd actions-runner
          fi
          
          # Remove existing runner configuration if present
          if [ -f ".runner" ]; then
            echo "Removing existing runner configuration..."
            sudo -u ubuntu ./config.sh remove --token "$2" || true
          fi
          
          # Configure runner with ephemeral flag and custom labels
          echo "Configuring runner..."
          sudo -u ubuntu ./config.sh \
            --url "$1" \
            --token "$2" \
            --name "$3" \
            --labels "gha_aws_runner,ubuntu-22.04,ephemeral" \
            --work "_work" \
            --ephemeral \
            --unattended \
            --replace
          
          # Start runner as service
          echo "Starting runner service..."
          sudo ./svc.sh install ubuntu
          sudo ./svc.sh start
          
          # Verify runner is running
          sleep 5
          if sudo ./svc.sh status | grep -q "active (running)"; then
            echo "‚úÖ Runner registered and started successfully"
          else
            echo "‚ùå Runner service failed to start"
            sudo ./svc.sh status
            exit 1
          fi
          EOF
          
          echo "Runner registration script created for production use:"
          echo "1. Ensure SSH key is configured for ubuntu@$PUBLIC_IP"
          echo "2. Copy register_runner.sh to instance: scp register_runner.sh ubuntu@$PUBLIC_IP:~/"
          echo "3. Execute: ssh ubuntu@$PUBLIC_IP 'bash register_runner.sh \"$RUNNER_URL\" \"$REGISTRATION_TOKEN\" \"${{ env.RUNNER_NAME }}\"'"
          
          if [ "$RUNNER_MODE" = "organization" ]; then
            echo "4. Verify runner appears online in organization Settings > Actions > Runners"
            echo "5. Runner will be available to all repositories in the ${{ secrets.GITHUB_ORGANIZATION }} organization"
          else
            echo "4. Verify runner appears online in repository Settings > Actions > Runners"
            echo "5. Runner will be available to the ${{ secrets.GITHUB_USERNAME }}/${{ secrets.GITHUB_REPOSITORY }} repository only"
          fi
          
          # For demo purposes, output the runner name
          echo "runner-name=${{ env.RUNNER_NAME }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Runner registration script prepared for ${{ env.RUNNER_NAME }}"

  # Job 2: Execute on self-hosted runner to display tool versions
  list-tools:
    needs: start-runner
    runs-on: [self-hosted, gha_aws_runner]
    timeout-minutes: 15
    steps:
      - name: Verify runner environment
        run: |
          echo "=== Runner Environment Verification ==="
          echo "Runner name: $RUNNER_NAME"
          echo "Hostname: $(hostname)"
          echo "User: $(whoami)"
          echo "Working directory: $(pwd)"
          echo "Date: $(date)"

      - name: Display Docker version
        continue-on-error: true
        run: |
          echo "=== Docker Version ==="
          if command -v docker &> /dev/null; then
            docker --version || echo "‚ùå Docker version command failed"
            if docker info --format '{{.ServerVersion}}' 2>/dev/null; then
              echo "‚úÖ Docker daemon is running"
            else
              echo "‚ùå Docker daemon is not running or accessible"
            fi
          else
            echo "‚ùå Docker is not installed"
          fi

      - name: Display AWS CLI version
        continue-on-error: true
        run: |
          echo "=== AWS CLI Version ==="
          if command -v aws &> /dev/null; then
            aws --version || echo "‚ùå AWS CLI version command failed"
            echo "‚úÖ AWS CLI is installed"
          else
            echo "‚ùå AWS CLI is not installed"
          fi

      - name: Display Python version
        continue-on-error: true
        run: |
          echo "=== Python Version ==="
          if command -v python3 &> /dev/null; then
            python3 --version || echo "‚ùå Python version command failed"
            echo "‚úÖ Python 3 is installed"
          else
            echo "‚ùå Python 3 is not installed"
          fi
          
          if command -v pip3 &> /dev/null; then
            pip3 --version || echo "‚ùå pip3 version command failed"
            echo "‚úÖ pip3 is installed"
          else
            echo "‚ùå pip3 is not installed"
          fi

      - name: Display Java version
        continue-on-error: true
        run: |
          echo "=== Java Version ==="
          if command -v java &> /dev/null; then
            java -version || echo "‚ùå Java version command failed"
            echo "‚úÖ Java is installed"
          else
            echo "‚ùå Java is not installed"
          fi
          
          if command -v javac &> /dev/null; then
            javac -version || echo "‚ùå javac version command failed"
            echo "‚úÖ Java compiler is installed"
          else
            echo "‚ùå Java compiler is not installed"
          fi

      - name: Display Terraform version
        continue-on-error: true
        run: |
          echo "=== Terraform Version ==="
          if command -v terraform &> /dev/null; then
            terraform --version || echo "‚ùå Terraform version command failed"
            echo "‚úÖ Terraform is installed"
          else
            echo "‚ùå Terraform is not installed"
          fi

      - name: Display kubectl version
        continue-on-error: true
        run: |
          echo "=== kubectl Version ==="
          if command -v kubectl &> /dev/null; then
            kubectl version --client --output=yaml || echo "‚ùå kubectl version command failed"
            echo "‚úÖ kubectl is installed"
          else
            echo "‚ùå kubectl is not installed"
          fi

      - name: Display Helm version
        continue-on-error: true
        run: |
          echo "=== Helm Version ==="
          if command -v helm &> /dev/null; then
            helm version || echo "‚ùå Helm version command failed"
            echo "‚úÖ Helm is installed"
          else
            echo "‚ùå Helm is not installed"
          fi

      - name: Display system information
        continue-on-error: true
        run: |
          echo "=== System Information ==="
          uname -a || echo "‚ùå uname command failed"
          lsb_release -a || echo "‚ùå lsb_release command failed"
          df -h || echo "‚ùå df command failed"
          free -h || echo "‚ùå free command failed"
          
      - name: Tool installation summary
        run: |
          echo "=== Tool Installation Summary ==="
          
          TOOLS=("docker" "aws" "python3" "java" "terraform" "kubectl" "helm")
          INSTALLED_COUNT=0
          TOTAL_COUNT=${#TOOLS[@]}
          
          for tool in "${TOOLS[@]}"; do
            if command -v "$tool" &> /dev/null; then
              echo "‚úÖ $tool"
              INSTALLED_COUNT=$((INSTALLED_COUNT + 1))
            else
              echo "‚ùå $tool"
            fi
          done
          
          echo ""
          echo "Installed: $INSTALLED_COUNT/$TOTAL_COUNT tools"
          
          if [ $INSTALLED_COUNT -eq $TOTAL_COUNT ]; then
            echo "üéâ All required tools are installed!"
          else
            echo "‚ö†Ô∏è  Some tools are missing. Check the user_data.sh script."
          fi

  # Job 3: Clean up - unregister organization-level runner and stop EC2 instance
  stop-runner:
    needs: [start-runner, list-tools]
    runs-on: ubuntu-latest
    if: always()  # Always run cleanup, even if previous jobs failed
    timeout-minutes: 15
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Validate organization configuration
        run: |
          echo "=== Validating Organization Configuration ==="
          
          # Check if GITHUB_ORGANIZATION secret is set
          if [ -z "${{ secrets.GITHUB_ORGANIZATION }}" ]; then
            echo "‚ùå GITHUB_ORGANIZATION secret is not set"
            echo "Please configure this secret with your GitHub organization name"
            echo "Go to: Settings > Secrets and variables > Actions"
            exit 1
          fi
          
          echo "‚úÖ Organization: ${{ secrets.GITHUB_ORGANIZATION }}"
          
          # Validate GitHub PAT has admin:org scope by testing organization access
          ORG_RESPONSE=$(curl -s -w "%{http_code}" \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/${{ secrets.GITHUB_ORGANIZATION }}")
          
          ORG_HTTP_CODE="${ORG_RESPONSE: -3}"
          
          if [ "$ORG_HTTP_CODE" = "200" ]; then
            echo "‚úÖ GitHub PAT has organization access"
          else
            echo "‚ùå Failed to access organization. HTTP code: $ORG_HTTP_CODE"
            echo "Please ensure your GitHub PAT has 'admin:org' scope"
            exit 1
          fi

      - name: Unregister GitHub runner
        continue-on-error: true  # Don't fail if runner is already unregistered
        run: |
          # Determine runner mode and API endpoint
          if [ -n "${{ secrets.GITHUB_ORGANIZATION }}" ] && [ -z "${{ secrets.GITHUB_USERNAME }}" ]; then
            RUNNER_MODE="organization"
            API_ENDPOINT="https://api.github.com/orgs/${{ secrets.GITHUB_ORGANIZATION }}/actions/runners"
            echo "=== Unregistering Organization-Level GitHub Runner ==="
          elif [ -n "${{ secrets.GITHUB_USERNAME }}" ] && [ -n "${{ secrets.GITHUB_REPOSITORY }}" ]; then
            RUNNER_MODE="repository"
            API_ENDPOINT="https://api.github.com/repos/${{ secrets.GITHUB_USERNAME }}/${{ secrets.GITHUB_REPOSITORY }}/actions/runners"
            echo "=== Unregistering Repository-Level GitHub Runner ==="
          else
            echo "‚ùå Cannot determine runner mode from secrets"
            exit 1
          fi
          
          # Retry logic for API calls
          retry_count=0
          max_retries=${{ env.MAX_RETRIES }}
          
          while [ $retry_count -lt $max_retries ]; do
            echo "Attempt $((retry_count + 1)) of $max_retries to unregister runner"
            
            # Get runners list with error handling
            RUNNERS_RESPONSE=$(curl -s -w "%{http_code}" \
              -H "Authorization: token ${{ secrets.GH_PAT }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "$API_ENDPOINT")
            
            HTTP_CODE="${RUNNERS_RESPONSE: -3}"
            RUNNERS_JSON="${RUNNERS_RESPONSE%???}"
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Successfully retrieved $RUNNER_MODE runners list"
              
              # Find runner by name
              RUNNER_ID=$(echo "$RUNNERS_JSON" | jq -r ".runners[] | select(.name==\"${{ needs.start-runner.outputs.runner-name }}\") | .id")
              
              if [ "$RUNNER_ID" != "null" ] && [ -n "$RUNNER_ID" ]; then
                echo "‚úÖ Found $RUNNER_MODE runner ID: $RUNNER_ID"
                echo "Runner name: ${{ needs.start-runner.outputs.runner-name }}"
                
                # Get runner details for verification
                RUNNER_STATUS=$(echo "$RUNNERS_JSON" | jq -r ".runners[] | select(.name==\"${{ needs.start-runner.outputs.runner-name }}\") | .status")
                echo "Runner status: $RUNNER_STATUS"
                
                # Remove runner using appropriate API endpoint
                DELETE_ENDPOINT="${API_ENDPOINT}/$RUNNER_ID"
                DELETE_RESPONSE=$(curl -s -w "%{http_code}" -X DELETE \
                  -H "Authorization: token ${{ secrets.GH_PAT }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "$DELETE_ENDPOINT")
                
                DELETE_HTTP_CODE="${DELETE_RESPONSE: -3}"
                DELETE_BODY="${DELETE_RESPONSE%???}"
                
                if [ "$DELETE_HTTP_CODE" = "204" ]; then
                  echo "‚úÖ $RUNNER_MODE runner unregistered successfully"
                  break
                elif [ "$DELETE_HTTP_CODE" = "404" ]; then
                  echo "‚ÑπÔ∏è  Runner not found (may have been auto-removed due to ephemeral configuration)"
                  break
                else
                  echo "‚ùå Failed to unregister $RUNNER_MODE runner. HTTP code: $DELETE_HTTP_CODE"
                  echo "Response: $DELETE_BODY"
                  
                  # Check for specific error conditions
                  if [ "$DELETE_HTTP_CODE" = "403" ]; then
                    if [ "$RUNNER_MODE" = "organization" ]; then
                      echo "‚ùå Insufficient permissions. Ensure GitHub PAT has 'admin:org' scope"
                    else
                      echo "‚ùå Insufficient permissions. Ensure GitHub PAT has 'repo' scope and admin access"
                    fi
                  fi
                fi
              else
                echo "‚ÑπÔ∏è  $RUNNER_MODE runner not found or already unregistered"
                echo "Runner name searched: ${{ needs.start-runner.outputs.runner-name }}"
                
                # List available runners for debugging
                echo "Available $RUNNER_MODE runners:"
                echo "$RUNNERS_JSON" | jq -r '.runners[] | "- \(.name) (ID: \(.id), Status: \(.status))"' || echo "No runners found"
                break
              fi
            else
              echo "‚ùå Failed to get organization runners list. HTTP code: $HTTP_CODE"
              echo "Response: $RUNNERS_JSON"
              
              # Check for specific error conditions
              if [ "$HTTP_CODE" = "401" ]; then
                echo "‚ùå Authentication failed. Check GitHub PAT validity"
                exit 1
              elif [ "$HTTP_CODE" = "403" ]; then
                echo "‚ùå Insufficient permissions. Ensure GitHub PAT has 'admin:org' scope"
                exit 1
              elif [ "$HTTP_CODE" = "404" ]; then
                echo "‚ùå Organization not found or not accessible"
                exit 1
              fi
            fi
            
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "Retrying in ${{ env.RETRY_DELAY }} seconds..."
              sleep ${{ env.RETRY_DELAY }}
            fi
          done
          
          if [ $retry_count -eq $max_retries ]; then
            echo "‚ùå Failed to unregister organization runner after $max_retries attempts"
            echo "Manual cleanup may be required in GitHub organization settings"
          fi

      - name: Stop EC2 instance with enhanced error handling
        run: |
          echo "=== Stopping EC2 Instance ==="
          
          # Validate instance ID format
          if [[ ! "${{ needs.start-runner.outputs.instance-id }}" =~ ^i-[0-9a-f]{8,17}$ ]]; then
            echo "‚ùå Invalid EC2 instance ID format: ${{ needs.start-runner.outputs.instance-id }}"
            exit 1
          fi
          
          # Retry logic for AWS operations
          retry_count=0
          max_retries=${{ env.MAX_RETRIES }}
          
          while [ $retry_count -lt $max_retries ]; do
            echo "Attempt $((retry_count + 1)) of $max_retries to stop instance"
            
            # Check current instance state with enhanced error handling
            if INSTANCE_RESPONSE=$(aws ec2 describe-instances \
              --instance-ids ${{ needs.start-runner.outputs.instance-id }} \
              --output json 2>&1); then
              
              INSTANCE_STATE=$(echo "$INSTANCE_RESPONSE" | jq -r '.Reservations[0].Instances[0].State.Name')
              INSTANCE_TYPE=$(echo "$INSTANCE_RESPONSE" | jq -r '.Reservations[0].Instances[0].InstanceType')
              INSTANCE_AZ=$(echo "$INSTANCE_RESPONSE" | jq -r '.Reservations[0].Instances[0].Placement.AvailabilityZone')
              
              echo "‚úÖ Instance details retrieved:"
              echo "  - Instance ID: ${{ needs.start-runner.outputs.instance-id }}"
              echo "  - Current state: $INSTANCE_STATE"
              echo "  - Instance type: $INSTANCE_TYPE"
              echo "  - Availability zone: $INSTANCE_AZ"
              
              case "$INSTANCE_STATE" in
                "running")
                  echo "Instance is running, initiating stop..."
                  
                  # Stop instance with error handling
                  if STOP_RESPONSE=$(aws ec2 stop-instances \
                    --instance-ids ${{ needs.start-runner.outputs.instance-id }} \
                    --output json 2>&1); then
                    
                    echo "‚úÖ Stop command sent successfully"
                    echo "Stop response: $STOP_RESPONSE"
                    
                    # Wait for instance to stop with enhanced monitoring
                    echo "Waiting for instance to stop (timeout: ${{ env.INSTANCE_STOP_TIMEOUT }} seconds)..."
                    
                    start_time=$(date +%s)
                    while true; do
                      current_time=$(date +%s)
                      elapsed=$((current_time - start_time))
                      
                      if [ $elapsed -ge ${{ env.INSTANCE_STOP_TIMEOUT }} ]; then
                        echo "‚ùå Timeout waiting for instance to stop after ${elapsed}s"
                        break
                      fi
                      
                      # Check instance state
                      if CURRENT_STATE=$(aws ec2 describe-instances \
                        --instance-ids ${{ needs.start-runner.outputs.instance-id }} \
                        --query 'Reservations[0].Instances[0].State.Name' \
                        --output text 2>/dev/null); then
                        
                        echo "Instance state after ${elapsed}s: $CURRENT_STATE"
                        
                        if [ "$CURRENT_STATE" = "stopped" ]; then
                          echo "‚úÖ Instance stopped successfully after ${elapsed}s"
                          break 2  # Break out of both loops
                        elif [ "$CURRENT_STATE" = "stopping" ]; then
                          echo "Instance is stopping... (${elapsed}s elapsed)"
                        else
                          echo "‚ùå Unexpected state during stop: $CURRENT_STATE"
                          break
                        fi
                      else
                        echo "‚ùå Failed to check instance state during stop"
                        break
                      fi
                      
                      sleep 10
                    done
                  else
                    echo "‚ùå Failed to send stop command"
                    echo "Error: $STOP_RESPONSE"
                  fi
                  ;;
                "stopped")
                  echo "‚úÖ Instance is already stopped"
                  break
                  ;;
                "stopping")
                  echo "Instance is already stopping, waiting for completion..."
                  
                  # Wait for stop to complete
                  if timeout ${{ env.INSTANCE_STOP_TIMEOUT }} aws ec2 wait instance-stopped \
                    --instance-ids ${{ needs.start-runner.outputs.instance-id }}; then
                    echo "‚úÖ Instance stopped successfully"
                    break
                  else
                    echo "‚ùå Timeout waiting for instance to stop"
                  fi
                  ;;
                "terminated"|"terminating")
                  echo "‚ÑπÔ∏è  Instance is terminated or terminating"
                  break
                  ;;
                "pending"|"shutting-down")
                  echo "‚ÑπÔ∏è  Instance is in transitional state: $INSTANCE_STATE"
                  echo "Waiting for state to stabilize..."
                  sleep 30
                  ;;
                *)
                  echo "‚ùå Instance in unexpected state: $INSTANCE_STATE"
                  ;;
              esac
            else
              echo "‚ùå Failed to get instance information"
              echo "Error: $INSTANCE_RESPONSE"
              
              # Check if it's a permissions issue
              if echo "$INSTANCE_RESPONSE" | grep -q "UnauthorizedOperation"; then
                echo "‚ùå AWS permissions error. Check IAM permissions for EC2 operations"
                exit 1
              elif echo "$INSTANCE_RESPONSE" | grep -q "InvalidInstanceID"; then
                echo "‚ùå Invalid instance ID or instance does not exist"
                exit 1
              fi
            fi
            
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "Retrying in ${{ env.RETRY_DELAY }} seconds..."
              sleep ${{ env.RETRY_DELAY }}
            fi
          done
          
          if [ $retry_count -eq $max_retries ]; then
            echo "‚ùå Failed to stop instance after $max_retries attempts"
            echo "Manual intervention may be required"
            echo "Check AWS Console: https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#Instances:"
          fi

      - name: Cleanup summary and verification
        run: |
          echo "=== Cleanup Summary and Verification ==="
          echo "Organization: ${{ secrets.GITHUB_ORGANIZATION }}"
          echo "Runner: ${{ needs.start-runner.outputs.runner-name }}"
          echo "Instance: ${{ needs.start-runner.outputs.instance-id }}"
          echo "Region: ${{ env.AWS_REGION }}"
          
          # Final verification of runner removal
          echo ""
          echo "=== Final Verification ==="
          
          # Check if runner still exists in organization
          FINAL_CHECK=$(curl -s \
            -H "Authorization: token ${{ secrets.GH_PAT }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/orgs/${{ secrets.GITHUB_ORGANIZATION }}/actions/runners" | \
            jq -r ".runners[] | select(.name==\"${{ needs.start-runner.outputs.runner-name }}\") | .name" 2>/dev/null || echo "")
          
          if [ -z "$FINAL_CHECK" ]; then
            echo "‚úÖ Runner successfully removed from organization"
          else
            echo "‚ö†Ô∏è  Runner may still be registered in organization"
          fi
          
          # Check final instance state
          if FINAL_STATE=$(aws ec2 describe-instances \
            --instance-ids ${{ needs.start-runner.outputs.instance-id }} \
            --query 'Reservations[0].Instances[0].State.Name' \
            --output text 2>/dev/null); then
            echo "‚úÖ Final instance state: $FINAL_STATE"
          else
            echo "‚ùå Could not verify final instance state"
          fi
          
          echo ""
          echo "üßπ Cleanup process completed"
          echo ""
          echo "Next steps:"
          echo "1. Verify runner removal in GitHub organization settings:"
          echo "   https://github.com/orgs/${{ secrets.GITHUB_ORGANIZATION }}/settings/actions/runners"
          echo "2. Verify instance state in AWS Console:"
          echo "   https://console.aws.amazon.com/ec2/v2/home?region=${{ env.AWS_REGION }}#Instances:"
          echo "3. Check for any remaining costs in AWS billing dashboard"